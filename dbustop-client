#!/usr/bin/python

import sys
import signal
from optparse import OptionParser
from client.dbus_client_controller import DbusClientController
from client.network_thread import NetworkThread
from client.curses_ui_thread import CursesUIThread

def main():
    global controller
    options, args = handle_args()
    signal.signal(signal.SIGINT, sigint_handler)

    controller = DbusClientController()
    net_thread = NetworkThread(options.host, options.port)
    ui_thread = CursesUIThread()
    ui_thread.message_q = controller.message_q

    # Give the controller referneces to it's threads.
    controller.ui_thread = ui_thread
    controller.network_thread = net_thread

    # Register callbacks for network and UI events.
    net_thread.add_message_received_callback(controller.dbus_message_received)
    ui_thread.add_key_pressed_callback(controller.key_pressed)

    # Start threads and wait for them to finish.
    net_thread.start()
    ui_thread.start()

    # Use loops below so that interrupts can be handled.
    # Wait for network thread to finish
    net_thread.shutdown_event.wait(0.1)
    net_thread.join()
    # Wait for UI thread to finish
    ui_thread.shutdown_event.wait(0.1)
    ui_thread.join()

def handle_args():
    parser = OptionParser()
    parser.set_defaults(host='localhost', port=5006)
    parser.add_option('-s', '--host',
            action='store', type='string', dest='host',
            help='The host to connect to.')
    parser.add_option('-p', '--port',
            action='store', type='int', dest='port',
            help='The port to use.')
    return parser.parse_args()

def sigint_handler(signum, frame):
    global controller
    controller.shutdown_application()

if __name__ == "__main__":
    status = 0
    try:
        main()
    except Exception as e:
        import traceback
        traceback.print_exc()
        status = 1
    print 'exit status: %d' % status
    sys.exit(status)
