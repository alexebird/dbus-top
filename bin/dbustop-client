#!/usr/bin/python

import sys, os, signal
import Queue
from optparse import OptionParser

sys.path.insert(0, '.')
from dbustop.common import util
from dbustop.common.event.event import Event
from dbustop.client.network_thread import NetworkThread
from dbustop.client.curses_ui_thread import CursesUIThread

def main():
    options, args = handle_args()
    for s in [signal.SIGINT, signal.SIGTERM]:
        signal.signal(s, signal_handler)

    net_thread = NetworkThread(options.host, options.port)
    net_thread.start()

    ui_thread = CursesUIThread()
    ui_thread.start()

    # The Event-loop
    while True:
        try:
            event = util.global_msg_queue.get(True, 0.1)
            if event.origin == 'NetworkThread':
                #print event.data.to_string()
                ui_thread.data_model.append(event.data)
                ui_thread.refresh()
            elif event.origin == 'CursesUIThread':
                if event.data == 'q': break
            elif event.origin == 'signal_handler': break
        except Queue.Empty:
            pass

    # Close things down
    net_thread.shutdown()
    ui_thread.shutdown()

def signal_handler(signum, frame):
    util.global_msg_queue.put(Event('signal_handler', 'signal_interrupt_received', signum))

def handle_args():
    parser = OptionParser()
    parser.set_defaults(host='localhost', port=5006)
    parser.add_option('-s', '--host',
            action='store', type='string', dest='host',
            help='The host to connect to.')
    parser.add_option('-p', '--port',
            action='store', type='int', dest='port',
            help='The port to use.')
    return parser.parse_args()

if __name__ == "__main__":
    status = 0
    try:
        main()
    except Exception as e:
        import traceback
        traceback.print_exc()
        status = 1
    print 'exit status: %d' % status
    sys.exit(status)
